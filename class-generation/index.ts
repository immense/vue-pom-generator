import path from "node:path";
import process from "node:process";
import { IComponentDependencies, IDataTestId, upperFirst } from "../utils";
import fs from "node:fs";
// NOTE: This module intentionally does not depend on Babel parsing.

const AUTO_GENERATED_COMMENT =
    ' * DO NOT MODIFY BY HAND\n'
    + ' *\n'
    + ' * This file is auto-generated by vue-testid-injector.\n'
    + ' * Changes should be made in the generator/template, not in the generated output.\n'
    + ' */';
const eslintSuppressionHeader = '/* eslint-disable perfectionist/sort-imports */\n';

function toPosixRelativePath(fromDir: string, toFile: string): string {
    let rel = path.relative(fromDir, toFile).replace(/\\/g, "/");
    if (!rel.startsWith(".")) {
        rel = `./${rel}`;
    }
    return rel;
}

function changeExtension(filePath: string, expectedExt: string, nextExtWithDot: string): string {
    const parsed = path.parse(filePath);
    if (parsed.ext !== expectedExt)
        return filePath;
    return path.format({ ...parsed, base: `${parsed.name}${nextExtWithDot}`, ext: nextExtWithDot });
}

function stripExtension(filePath: string): string {
    const parsed = path.parse(filePath);
    return path.format({ ...parsed, base: parsed.name, ext: "" });
}

export interface GenerateFilesOptions {
    outDir?: string | { pages: string; components: string };
    singleFile?: boolean;

    /**
     * Project root used for resolving conventional paths (e.g. src/views, pom/custom).
     * Defaults to process.cwd() for backwards compatibility.
     */
    projectRoot?: string;

    /**
     * Directory containing handwritten POM helpers to import into aggregated output.
     * Defaults to <projectRoot>/pom/custom.
     */
    customPomDir?: string;

    /**
     * Optional import aliases for handwritten POM helpers.
     *
     * Keyed by the helper file/export name (basename of the .ts file).
     * Value is the identifier to import it as.
     *
     * Example: { Toggle: "ToggleWidget" }
     */
    customPomImportAliases?: Record<string, string>;

    /**
     * Handwritten POM helper attachments. These helpers are assumed to be present in the
     * aggregated output (e.g. via `pom/custom/*.ts` inlining), but we only attach them to
     * view classes that actually use certain components.
     */
    customPomAttachments?: Array<{
        className: string;
        propertyName: string;
        attachWhenUsesComponents: string[];

        /**
         * Controls whether this attachment is applied to views, components, or both.
         * Defaults to "views" for backwards compatibility.
         */
        attachTo?: "views" | "components" | "both";
    }>;

    /** Attribute name to treat as the test id. Defaults to `data-testid`. */
    testIdAttribute?: string;
}

interface GenerateContentOptions {
    /** Directory the generated .g.ts file will live in (used for relative imports). Defaults to the Vue file's directory. */
    outputDir?: string;
    /** When true, omit file headers/import blocks that should be shared in an aggregated file. */
    aggregated?: boolean;

    customPomAttachments?: Array<{
        className: string;
        propertyName: string;
        attachWhenUsesComponents: string[];

        /**
         * Controls whether this attachment is applied to views, components, or both.
         * Defaults to "views" for backwards compatibility.
         */
        attachTo?: "views" | "components" | "both";
    }>;

    projectRoot?: string;
    customPomDir?: string;
    customPomImportAliases?: Record<string, string>;

    /** Attribute name to treat as the test id. Defaults to `data-testid`. */
    testIdAttribute?: string;
}

export async function generateFiles(
    componentHierarchyMap: Map<string, IComponentDependencies>,
    vueFilesPathMap: Map<string, string>,
    basePageClassPath: string,
    options: GenerateFilesOptions = {},
) {
    const {
        outDir,
        singleFile = false,
        customPomAttachments = [],
        projectRoot,
        customPomDir,
        customPomImportAliases,
        testIdAttribute,
    } = options;

    // Default legacy behavior: write per-component next to the .vue file.
    if (!outDir) {
        for (const [componentName, dependencies] of componentHierarchyMap.entries()) {
            const { filePath, content } = generateViewObjectModel(componentName, dependencies, componentHierarchyMap, vueFilesPathMap, basePageClassPath, { customPomAttachments, testIdAttribute });
            createFile(filePath, content);
        }
        return;
    }

    if (singleFile) {
        const files = generateAggregatedFiles(componentHierarchyMap, vueFilesPathMap, basePageClassPath, outDir, {
            customPomAttachments,
            projectRoot,
            customPomDir,
            customPomImportAliases,
            testIdAttribute,
        });
        for (const file of files) {
            createFile(file.filePath, file.content);
        }
        return;
    }

    // outDir provided, per-component output
    for (const [componentName, dependencies] of componentHierarchyMap.entries()) {
        const newFilePath = getGeneratedFilePathForComponent(dependencies, outDir);
        if (!newFilePath) continue;
        const content = generateViewObjectModelContent(componentName, dependencies, componentHierarchyMap, vueFilesPathMap, basePageClassPath, {
            outputDir: path.dirname(newFilePath),

            customPomAttachments,

            projectRoot,
            customPomDir,
            customPomImportAliases,
            testIdAttribute,
        });
        createFile(newFilePath, content);
    }
}

function generateViewObjectModel(
    componentName: string,
    dependencies: IComponentDependencies,
    componentHierarchyMap: Map<string, IComponentDependencies>,
    vueFilesPathMap: Map<string, string>,
    basePageClassPath: string,
    options: {
        customPomAttachments?: GenerateFilesOptions["customPomAttachments"];
        testIdAttribute?: GenerateFilesOptions["testIdAttribute"];
    } = {},
) {
    const filePath = changeExtension(dependencies.filePath, ".vue", ".g.ts");
    const content = generateViewObjectModelContent(componentName, dependencies, componentHierarchyMap, vueFilesPathMap, basePageClassPath, {
        outputDir: path.dirname(filePath),

        customPomAttachments: options.customPomAttachments ?? [],
        testIdAttribute: options.testIdAttribute,
    });
    return { filePath, content };
}


export function generateViewObjectModelMethodContent(
    targetPageObjectModelClass: string | undefined,
    methodName: string,
    nativeRole: string,
    formattedDataTestId: string,
    params: Record<string, string>,
) {

    const baseMethodName = (nativeRole === "radio")
        ? (methodName || "Radio")
        : methodName;

    const getElementMethod = generateGetElementByDataTestId(baseMethodName, nativeRole, formattedDataTestId, params);

    if (targetPageObjectModelClass) {
        return getElementMethod + generateNavigationMethod({
            targetPageObjectModelClass,
            baseMethodName,
            formattedDataTestId,
            params,
        });
    }

    if (nativeRole === 'select') {
        return getElementMethod + generateSelectMethod(baseMethodName, formattedDataTestId);
    }
    if (nativeRole === "vselect") {
        return getElementMethod + generateVSelectMethod(baseMethodName, formattedDataTestId);
    }
    if (nativeRole === 'input') {
        return getElementMethod + generateTypeMethod(baseMethodName, formattedDataTestId);
    }
    if (nativeRole === "radio") {
        return getElementMethod + generateRadioMethod(baseMethodName || 'Radio', formattedDataTestId);
    }

    return getElementMethod + generateClickMethod(baseMethodName, formattedDataTestId, params);
}

function generateNavigationMethod(args: {
    targetPageObjectModelClass: string;
    /** Method name derived from data-testid parts (already PascalCase). */
    baseMethodName: string;
    /** data-testid string (may include `${key}` placeholder). */
    formattedDataTestId: string;
    /** Method param name->type dictionary (e.g. { key: "string" }). */
    params: Record<string, string>;
}) {
    const { targetPageObjectModelClass: target, baseMethodName, formattedDataTestId, params } = args;

    // IMPORTANT:
    // Navigation method names must be derived from the element's semantic name (data-testid parts)
    // rather than only from the target page class. Multiple elements often navigate to the same
    // target (e.g. NewBranding + EditBranding -> BrandingDetailsPage). If we name methods by
    // target only, we emit duplicate implementations and vue-tsc fails.
    const methodName = baseMethodName
        ? `goTo${upperFirst(baseMethodName)}`
        : `goTo${target.endsWith("Page") ? target.slice(0, -"Page".length) : target}`;

    const signature = `public ${methodName}(${formatParams(params)}): Fluent<${target}>`;
    const clickExpr = hasParam(params, "key")
        ? `\`${formattedDataTestId}\``
        : `\`${formattedDataTestId}\``;

    const body = `
        ${signature} {
        return this.fluent(async () => {
        await this.clickByTestId(${clickExpr});
        return new ${target}(this.page);
    });
    }
`;

    return body;
}

function hasParam(params: Record<string, string>, name: string) {
    return Object.prototype.hasOwnProperty.call(params, name);
}

function formatParams(params: Record<string, string>) {
    const entries = Object.entries(params);
    if (!entries.length) {
        return "";
    }
    return entries.map(([n, t]) => `${n}: ${t}`).join(", ");
}

function generateViewObjectModelContent(
    componentName: string,
    dependencies: IComponentDependencies,
    componentHierarchyMap: Map<string, IComponentDependencies>,
    vueFilesPathMap: Map<string, string>,
    basePageClassPath: string,
    options: GenerateContentOptions = {},
) {
    const { isView, childrenComponentSet, usedComponentSet, filePath } = dependencies;

    const {
        outputDir = path.dirname(filePath),
        aggregated = false,
        customPomAttachments = [],
        testIdAttribute,
    } = options;

    const hasChildComponent = (needle: string) => {
        const haystack = usedComponentSet?.size ? usedComponentSet : childrenComponentSet;
        for (const child of haystack) {
            if (child === needle) return true;
            if (child === `${needle}.vue`) return true;
            if (child.endsWith(".vue") && child.slice(0, -4) === needle) return true;
        }
        return false;
    };

    const attachmentsForThisClass = customPomAttachments
        .filter((a) => {
            const scope = a.attachTo ?? "views";
            const scopeOk = isView
                ? (scope === "views" || scope === "both")
                : (scope === "components" || scope === "both");
            if (!scopeOk) return false;
            return a.attachWhenUsesComponents.some((c) => hasChildComponent(c));
        })
        .map((a) => ({ className: a.className, propertyName: a.propertyName }));

    let content: string = '';

    const sourceRel = toPosixRelativePath(outputDir, filePath);
    const kind = isView ? "Page" : "Component";
    const doc = `/** ${kind} POM: ${componentName} (source: ${sourceRel}) */\n`;

    // In aggregated mode, imports are hoisted once at the top of the file.
    if (!aggregated) {
        content = `${eslintSuppressionHeader}${doc}`;

        // We only need PwPage when we emit a constructor (views always do; components only do
        // when they have custom attachments like Grid).
        if (isView || attachmentsForThisClass.length > 0) {
            content += 'import type { Page as PwPage } from "@playwright/test";\n'
        }

        const projectRoot = options.projectRoot ?? process.cwd();
        const fromAbs = path.isAbsolute(outputDir) ? outputDir : path.resolve(projectRoot, outputDir);
        const toAbs = basePageClassPath
            ? (path.isAbsolute(basePageClassPath) ? basePageClassPath : path.resolve(projectRoot, basePageClassPath))
            : "";
        const basePageImport = path.relative(fromAbs, toAbs).replace(/\\/g, "/");
        const basePageImportNoExt = stripExtension(basePageImport);
        const basePageImportSpecifier = basePageImportNoExt.startsWith(".") ? basePageImportNoExt : `./${basePageImportNoExt}`;
        content += `import { BasePage, Fluent } from '${basePageImportSpecifier}';\n\n`;

        if (isView && childrenComponentSet.size > 0) {
            childrenComponentSet.forEach((child) => {
                if (componentHierarchyMap.has(child) && componentHierarchyMap.get(child)?.dataTestIdSet.size) {
                    const childPath = vueFilesPathMap.get(child);
                    let relativePath = path.relative(outputDir, childPath || '');
                    relativePath = changeExtension(relativePath, ".vue", ".g");
                    content += `import { ${child} } from '${relativePath}';\n`;
                }
            });
        }
    } else {
        // Keep per-class doc comment, but avoid repeating eslint suppression / imports.
        content = doc;
    }

    content += `\nexport class ${componentName} extends BasePage {\n`

    const widgetInstances = isView
        ? getWidgetInstancesForView(componentName, dependencies.dataTestIdSet)
        : [];

    // For views, `childrenComponentSet` only includes component tags on which we applied a data-testid.
    // Thin wrapper views (e.g. NewTenantPage) may have *no* generated test ids but still contain
    // important child component POMs (forms, grids, etc). In those cases, we use `usedComponentSet`
    // to discover and instantiate child component POMs.
    const componentRefsForInstances = isView
        ? (usedComponentSet?.size ? usedComponentSet : childrenComponentSet)
        : childrenComponentSet;

    // Only views get child component instance fields by default.
    // Components will only get a constructor/fields when they have explicit custom attachments
    // (e.g. wrapper components around a third-party data grid should get a `grid: Grid`).
    if (isView && (componentRefsForInstances.size > 0 || attachmentsForThisClass.length > 0 || widgetInstances.length > 0)) {
        content += getComponentInstances(componentRefsForInstances, componentHierarchyMap, attachmentsForThisClass, widgetInstances);
        content += getConstructor(componentRefsForInstances, componentHierarchyMap, attachmentsForThisClass, widgetInstances, { testIdAttribute });
    }
    if (!isView && attachmentsForThisClass.length > 0) {
        content += getComponentInstances(new Set(), componentHierarchyMap, attachmentsForThisClass);
        content += getConstructor(new Set(), componentHierarchyMap, attachmentsForThisClass, [], { testIdAttribute });
    }

    // Ergonomics: when a view is primarily composed of a single component POM (e.g. a form),
    // allow calling that component's methods directly on the page class.
    //
    // Example:
    //   await tenantListPage.goToNewTenant().typeTenantName(...).clickCreateTenant();
    //
    // Rules:
    // - Only for views (not components) to avoid polluting component surfaces.
    // - Only generate pass-throughs when the method is unambiguous across child components.
    // - Never generate a pass-through that would collide with an existing method on the view.
    if (isView && componentRefsForInstances.size > 0) {
        content += getViewPassthroughMethods(componentName, dependencies, componentRefsForInstances, componentHierarchyMap);
    }

    if (dependencies.methodsContent === undefined) {
        throw new Error(
            `methodsContent was not generated for ${componentName}. ` +
            `It should be computed during the Vue transform phase (RootNode exit).`,
        );
    }

    content += dependencies.methodsContent;

    content += '}\n';
    return content;
}

function getViewPassthroughMethods(
    viewName: string,
    viewDependencies: IComponentDependencies,
    childrenComponentSet: Set<string>,
    componentHierarchyMap: Map<string, IComponentDependencies>,
) {
    const existingOnView = viewDependencies.generatedMethods ?? new Map<string, { params: string; argNames: string[] } | null>();

    // methodName -> candidates
    const methodToChildren = new Map<string, Array<{ childProp: string; params: string; argNames: string[] }>>();

    for (const child of childrenComponentSet) {
        const childDeps = componentHierarchyMap.get(child);
        if (!childDeps || !childDeps.dataTestIdSet?.size) continue;

        const methods = childDeps.generatedMethods;
        if (!methods) continue;

        // Property name matches how we emit instance fields (strip .vue if present).
        const childProp = child.endsWith(".vue") ? child.slice(0, -4) : child;

        for (const [name, sig] of methods.entries()) {
            if (!sig) continue; // ambiguous on the child itself

            // If the view already has this method name, never generate a pass-through.
            if (existingOnView.has(name)) continue;

            const list = methodToChildren.get(name) ?? [];
            list.push({ childProp, params: sig.params, argNames: sig.argNames });
            methodToChildren.set(name, list);
        }
    }

    const sorted = Array.from(methodToChildren.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    const lines: string[] = [];

    for (const [methodName, candidates] of sorted) {
        // Only generate when exactly one child can satisfy the call.
        if (candidates.length !== 1) continue;

        const { childProp, params, argNames } = candidates[0];
        const callArgs = argNames.join(", ");

        lines.push(
            "",
            `    async ${methodName}(${params}) {`,
            `        return await this.${childProp}.${methodName}(${callArgs});`,
            "    }",
        );
    }

    if (!lines.length) {
        return "";
    }

    return [
        "",
        `    // Passthrough methods composed from child component POMs of ${viewName}.`,
        ...lines,
        "",
    ].join("\n");
}

function ensureDir(dir: string) {
    const normalized = dir.replace(/\\/g, "/");
    if (!fs.existsSync(normalized)) {
        fs.mkdirSync(normalized, { recursive: true });
    }
    return normalized;
}

function getGeneratedFilePathForComponent(dependencies: IComponentDependencies, outDir: string | { pages: string; components: string }) {
    const { isView } = dependencies;
    if (typeof outDir === "string") {
        const base = ensureDir(outDir);
        const sub = ensureDir(path.join(base, isView ? "Pages" : "Components"));
        const name = path.basename(dependencies.filePath).replace('.vue', '.g.ts');
        return path.join(sub, name);
    }

    const targetBase = ensureDir(isView ? outDir.pages : outDir.components);
    const name = path.basename(dependencies.filePath).replace('.vue', '.g.ts');
    return path.join(targetBase, name);
}

function generateAggregatedFiles(
    componentHierarchyMap: Map<string, IComponentDependencies>,
    vueFilesPathMap: Map<string, string>,
    basePageClassPath: string,
    outDir: string | { pages: string; components: string },
    options: {
        customPomAttachments?: GenerateFilesOptions["customPomAttachments"];
        projectRoot?: GenerateFilesOptions["projectRoot"];
        customPomDir?: GenerateFilesOptions["customPomDir"];
        customPomImportAliases?: GenerateFilesOptions["customPomImportAliases"];
        testIdAttribute?: GenerateFilesOptions["testIdAttribute"];
    } = {},
) {
    const projectRoot = options.projectRoot ?? process.cwd();
    const entries = Array.from(componentHierarchyMap.entries())
        .sort((a, b) => a[0].localeCompare(b[0]));

    const views = entries.filter(([, d]) => d.isView);
    const components = entries.filter(([, d]) => !d.isView);

    const getImportPath = (fromDir: string, toAbsPath: string) => {
        // Ensure stable separators since generated files are consumed by Vite/TS.
        // IMPORTANT: `fromDir` is frequently a relative path like "./pom"; resolve it
        // against the project root before computing a relative import to an absolute file.
        const fromAbs = path.isAbsolute(fromDir) ? fromDir : path.resolve(projectRoot, fromDir);
        const toAbs = path.isAbsolute(toAbsPath) ? toAbsPath : path.resolve(projectRoot, toAbsPath);
        let rel = path.relative(fromAbs, toAbs).replace(/\\/g, "/");
        // Strip TypeScript extension for module import.
        rel = rel.replace(/\.ts$/i, "");
        if (!rel.startsWith(".")) {
            rel = `./${rel}`;
        }
        return rel;
    };

    const makeAggregatedContent = (
        header: string,
        outputDir: string,
        items: Array<[string, IComponentDependencies]>,
    ) => {
        // Alias Playwright types to avoid collisions with generated classes (e.g. a Vue component named `Page`).
        const imports: string[] = ['import type { Locator as PwLocator, Page as PwPage } from "@playwright/test";'];

        if (!basePageClassPath) {
            throw new Error("basePageClassPath is required for singleFile generation");
        }

        // Inline BasePage into the aggregated output.
        //
        // Why:
        // - Playwright's runtime loader can treat workspace packages (like `vue-testid-injector`)
        //   as external and not apply TS transforms/module resolution consistently.
        // - Importing a .ts file from inside a "type": "module" package can fail with
        //   "Cannot find module" at runtime.
        //
        // Inlining keeps the generated POMs self-contained and stable across platforms.
        const inlineBasePageModule = () => {
            const clickInstrumentationInline = [
                "export const TESTID_CLICK_EVENT_NAME = \"__testid_event__\";",
                "export const TESTID_CLICK_EVENT_STRICT_FLAG = \"__testid_click_event_strict__\";",
                "export interface TestIdClickEventDetail {",
                "  testId?: string;",
                "  phase?: \"before\" | \"after\" | \"error\" | string;",
                "  err?: string;",
                "}",
            ].join("\n");

            let basePageSource = "";
            try {
                basePageSource = fs.readFileSync(basePageClassPath, "utf8");
            }
            catch {
                throw new Error(`Failed to read BasePage.ts at ${basePageClassPath}`);
            }

            // Replace the click-instrumentation import with an inline copy.
            basePageSource = basePageSource.replace(
                /import\s*\{[\s\S]*?\}\s*from\s*["']\.\.\/click-instrumentation["'];?\s*/,
                `${clickInstrumentationInline}\n\n`,
            );

            // The aggregated file already imports these Playwright types once at the top.
            // Remove BasePage's own import to avoid duplicate identifiers.
            basePageSource = basePageSource.replace(
                /import\s+type\s*\{\s*Locator\s+as\s+PwLocator\s*,\s*Page\s+as\s+PwPage\s*\}\s*from\s*["']@playwright\/test["'];?\s*/,
                "",
            );

            return basePageSource.trim();
        };

        const basePageInline = inlineBasePageModule();

        // Handwritten POM helpers for complicated/third-party widgets.
        // Convention: place them in `frontend/pom/custom/*.ts`.
        // Import them rather than inlining so TypeScript can typecheck them.
        const addCustomPomImports = () => {
            // Some custom POM helpers intentionally share names with generated component POMs
            // (e.g. Toggle.vue -> generated class `Toggle`). Import with aliases to avoid
            // merged-declaration conflicts in the aggregated output.
            const importAliases: Record<string, string> = {
                Toggle: "ToggleWidget",
                Checkbox: "CheckboxWidget",
                ...(options.customPomImportAliases ?? {}),
            };

            const customDir = options.customPomDir ?? path.join(projectRoot, "pom/custom");
            if (!fs.existsSync(customDir)) {
                return;
            }

            const files = fs.readdirSync(customDir)
                .filter((f) => f.endsWith(".ts"))
                .sort((a, b) => a.localeCompare(b));

            for (const file of files) {
                const exportName = file.replace(/\.ts$/i, "");
                // In this repo, custom POMs are authored as `export class <Name> { ... }`.
                // Import by the basename, which matches the class name convention.
                const alias = importAliases[exportName];
                if (alias) {
                    imports.push(`import { ${exportName} as ${alias} } from "./custom/${exportName}";`);
                }
                else {
                    imports.push(`import { ${exportName} } from "./custom/${exportName}";`);
                }
            }
        };

        addCustomPomImports();

        // Collect any navigation return types referenced by generated methods so we can emit
        // stub classes when the destination view has no generated test ids (and therefore no
        // corresponding POM class in this file).
        const referencedTargets = new Set<string>();
        for (const [, deps] of items) {
            for (const dt of deps.dataTestIdSet) {
                if (dt.targetPageObjectModelClass) {
                    referencedTargets.add(dt.targetPageObjectModelClass);
                }
            }
        }

        const generatedClassNames = new Set(items.map(([name]) => name));
        const stubTargets = Array.from(referencedTargets)
            .filter((t) => !generatedClassNames.has(t))
            .sort((a, b) => a.localeCompare(b));

        const availableClassNames = new Set<string>([...generatedClassNames, ...stubTargets]);

        const depsByClassName = new Map<string, IComponentDependencies>(entries);

        const scanPascalCaseTags = (template: string) => {
            // Extracts tag names like <TenantDetailsEditForm ...> without regex.
            // We only care about PascalCase component tags.
            const names: string[] = [];
            const len = template.length;
            let i = 0;
            while (i < len) {
                const ch = template[i];
                if (ch !== "<") {
                    i++;
                    continue;
                }

                i++; // consume '<'
                if (i >= len) break;

                // Skip closing tags and directives/comments
                if (template[i] === "/" || template[i] === "!" || template[i] === "?") {
                    i++;
                    continue;
                }

                // Skip whitespace
                while (i < len && (template[i] === " " || template[i] === "\n" || template[i] === "\t" || template[i] === "\r")) i++;
                if (i >= len) break;

                const first = template[i];
                // Only PascalCase (starts with A-Z)
                if (first < "A" || first > "Z") {
                    continue;
                }

                const start = i;
                i++;
                while (i < len) {
                    const c = template[i];
                    const isLetter = (c >= "A" && c <= "Z") || (c >= "a" && c <= "z");
                    const isDigit = c >= "0" && c <= "9";
                    const isUnderscore = c === "_";
                    if (isLetter || isDigit || isUnderscore) {
                        i++;
                        continue;
                    }
                    break;
                }
                const name = template.slice(start, i);
                if (name) names.push(name);
            }
            return Array.from(new Set(names));
        };

        const getComposedStubBody = (targetClassName: string) => {
            const mapped = vueFilesPathMap.get(targetClassName);
            const candidates = [
                mapped,
                path.join(projectRoot, "src", "views", `${targetClassName}.vue`),
                path.join(projectRoot, "src", "components", `${targetClassName}.vue`),
            ].filter((p): p is string => typeof p === "string" && p.length > 0);

            const filePath = candidates.find((p) => fs.existsSync(p));
            if (!filePath) return undefined;

            // Heuristic: scan the SFC template for PascalCase tags. If we have generated
            // POM classes for those components, include them as composed children.
            let source = "";
            try {
                source = fs.readFileSync(filePath, "utf8");
            } catch {
                return undefined;
            }

            const templateOpen = source.indexOf("<template");
            const templateClose = source.lastIndexOf("</template>");
            if (templateOpen === -1 || templateClose === -1 || templateClose <= templateOpen) return undefined;

            const afterOpenTag = source.indexOf(">", templateOpen);
            if (afterOpenTag === -1 || afterOpenTag >= templateClose) return undefined;

            const template = source.slice(afterOpenTag + 1, templateClose);
            if (!template) return undefined;

            const tags = scanPascalCaseTags(template);
            const childClassNames = Array.from(
                new Set(
                    tags
                        .filter((name) => availableClassNames.has(name))
                        .filter((name) => name !== targetClassName),
                ),
            ).sort((a, b) => a.localeCompare(b));

            if (!childClassNames.length) return undefined;

            // Build passthrough methods from stub -> child component when the method is unambiguous.
            // This enables ergonomics like:
            //   await tenantListPage.goToNewTenant().typeTenantName(...)
            // without forcing the test to reference `.TenantDetailsEditForm`.
            const methodToChildren = new Map<string, Array<{ child: string; params: string; argNames: string[] }>>();
            for (const child of childClassNames) {
                const childDeps = depsByClassName.get(child);
                const methods = childDeps?.generatedMethods;
                if (!methods) continue;

                for (const [name, sig] of methods.entries()) {
                    if (!sig) continue; // ambiguous
                    const list = methodToChildren.get(name) ?? [];
                    list.push({ child, params: sig.params, argNames: sig.argNames });
                    methodToChildren.set(name, list);
                }
            }

            const passthroughLines: string[] = [];
            for (const [methodName, candidatesForMethod] of methodToChildren.entries()) {
                if (candidatesForMethod.length !== 1) continue;

                // Avoid creating pass-throughs for internal-ish helpers.
                if (methodName === "constructor") continue;

                const { child, params, argNames } = candidatesForMethod[0];
                const callArgs = argNames.join(", ");

                passthroughLines.push(
                    "",
                    `    async ${methodName}(${params}) {`,
                    `        return await this.${child}.${methodName}(${callArgs});`,
                    "    }",
                );
            }

            return {
                childClassNames,
                lines: [
                    ...childClassNames.map((c) => `    ${c}: ${c};`),
                    "",
                    "    constructor(page: PwPage) {",
                    "        super(page);",
                    ...childClassNames.map((c) => `        this.${c} = new ${c}(page);`),
                    "    }",
                    ...passthroughLines,
                ],
            };
        };

        const stubs = stubTargets.map((t) =>
            (() => {
                const composed = getComposedStubBody(t);
                const body = composed?.lines ?? [
                    "    constructor(page: PwPage) {",
                    "        super(page);",
                    "    }",
                ];

                return [
                    "/**\n * Stub POM generated because it is referenced as a navigation target but\n * did not have any generated test ids in this build.\n */",
                    `export class ${t} extends BasePage {`,
                    ...body,
                    "}",
                ].join("\n");
            })(),
        );

        const classes = items.map(([name, deps]) =>
            generateViewObjectModelContent(name, deps, componentHierarchyMap, vueFilesPathMap, basePageClassPath, {
                outputDir,
                aggregated: true,

                customPomAttachments: options.customPomAttachments ?? [],
                testIdAttribute: options.testIdAttribute,
            }),
        );

        return [
            header,
            ...imports,
            "",
            basePageInline,
            "",
            ...classes,
            ...(stubs.length ? ["", ...stubs] : []),
        ].join("\n\n");
    };

    if (typeof outDir === "string") {
        const base = ensureDir(outDir);
        const outputFile = path.join(base, "index.g.ts");
        const header = `${eslintSuppressionHeader}/**\n * Aggregated generated POMs\n${AUTO_GENERATED_COMMENT}`;
        const content = makeAggregatedContent(header, path.dirname(outputFile), [...views, ...components]);

        const indexFile = path.join(base, "index.ts");
        const indexContent = `${eslintSuppressionHeader}/**\n * POM exports\n${AUTO_GENERATED_COMMENT}\n\nexport * from \"./index.g\";\n`;

        return [
            { filePath: outputFile, content },
            { filePath: indexFile, content: indexContent },
        ];
    }

    const pagesDir = ensureDir(outDir.pages);
    const componentsDir = ensureDir(outDir.components);

    const pagesFile = path.join(pagesDir, "index.g.ts");
    const componentsFile = path.join(componentsDir, "index.g.ts");

    const pagesIndexFile = path.join(pagesDir, "index.ts");
    const componentsIndexFile = path.join(componentsDir, "index.ts");

    const pagesHeader = `${eslintSuppressionHeader}/**\n * Aggregated generated POMs (Pages/Views)\n${AUTO_GENERATED_COMMENT}`;
    const componentsHeader = `${eslintSuppressionHeader}/**\n * Aggregated generated POMs (Components)\n${AUTO_GENERATED_COMMENT}`;

    const pagesContent = makeAggregatedContent(pagesHeader, path.dirname(pagesFile), views);
    const componentsContent = makeAggregatedContent(componentsHeader, path.dirname(componentsFile), components);

    const pagesIndexContent = `${eslintSuppressionHeader}/**\n * POM exports (Pages/Views)\n${AUTO_GENERATED_COMMENT}\n\nexport * from \"./index.g\";\n`;
    const componentsIndexContent = `${eslintSuppressionHeader}/**\n * POM exports (Components)\n${AUTO_GENERATED_COMMENT}\n\nexport * from \"./index.g\";\n`;

    return [
        { filePath: pagesFile, content: pagesContent },
        { filePath: componentsFile, content: componentsContent },
        { filePath: pagesIndexFile, content: pagesIndexContent },
        { filePath: componentsIndexFile, content: componentsIndexContent },
    ];
}

function createFile(filePath: string, content: string) {
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
    }
    if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
    }
    fs.writeFileSync(filePath, content);
}

function lowerFirst(value: string): string {
    if (!value) return value;
    return value.charAt(0).toLowerCase() + value.slice(1);
}

function toPascalCaseLocal(str: string): string {
    const cleaned = (str ?? "")
        .replace(/\$\{[^}]*\}/g, " ")
        .replace(/[^a-z0-9]+/gi, " ")
        .trim();

    if (!cleaned) return "";

    return cleaned
        .split(/\s+/)
        .filter(Boolean)
        .map((word) => {
            const preserveInternalCaps = /[a-z][A-Z]/.test(word);
            return preserveInternalCaps
                ? upperFirst(word)
                : upperFirst(word.toLowerCase());
        })
        .join("");
}

interface WidgetInstance {
    className: "ToggleWidget" | "CheckboxWidget";
    propertyName: string;
    testId: string;
}

function getWidgetInstancesForView(componentName: string, dataTestIdSet: Set<IDataTestId>): WidgetInstance[] {
    const out: WidgetInstance[] = [];
    const usedPropNames = new Set<string>();

    const ensureUnique = (base: string) => {
        let candidate = base;
        let i = 2;
        while (usedPropNames.has(candidate)) {
            candidate = `${base}${i}`;
            i++;
        }
        usedPropNames.add(candidate);
        return candidate;
    };

    for (const dt of dataTestIdSet) {
        const raw = dt.value;

        // Skip keyed/dynamic test ids; instance fields can't represent those ergonomically.
        if (raw.includes("${")) {
            continue;
        }

        const toggleSuffix = "-toggle";
        const checkboxSuffix = "-checkbox";

        let className: WidgetInstance["className"] | null = null;
        let stem = "";

        if (raw.endsWith(toggleSuffix)) {
            className = "ToggleWidget";
            stem = raw.slice(0, -toggleSuffix.length);
        } else if (raw.endsWith(checkboxSuffix)) {
            className = "CheckboxWidget";
            stem = raw.slice(0, -checkboxSuffix.length);
        } else {
            continue;
        }

        // Prefer stripping the view prefix (e.g. PreferencesPage-) for cleaner member names.
        const viewPrefix = `${componentName}-`;
        const descriptorRaw = stem.startsWith(viewPrefix) ? stem.slice(viewPrefix.length) : stem;
        const descriptorPascal = toPascalCaseLocal(descriptorRaw);

        if (!descriptorPascal) {
            continue;
        }

        if (className === "ToggleWidget") {
            let base = descriptorPascal.replace(/Toggle$/i, "");

            // Ergonomic naming: if a toggle name contains an "Enable..." tail, prefer that tail.
            // Example: AppPreferencesEnableSessionEmails -> enableSessionEmailsToggle
            const enableIndex = base.indexOf("Enable");
            if (enableIndex > 0) {
                base = base.slice(enableIndex);
            }

            const propBase = lowerFirst(base);
            const propName = ensureUnique(propBase ? `${propBase}Toggle` : "toggle");
            out.push({ className, propertyName: propName, testId: raw });
            continue;
        }

        // Checkbox
        const base = descriptorPascal
            .replace(/CheckBox$/i, "")
            .replace(/Checkbox$/i, "");
        const propBase = lowerFirst(base);
        const propName = ensureUnique(propBase ? `${propBase}Checkbox` : "checkbox");
        out.push({ className, propertyName: propName, testId: raw });
    }

    return out;
}

function getComponentInstances(
    childrenComponent: Set<string>,
    componentHierarchyMap: Map<string, IComponentDependencies>,
    attachmentsForThisView: Array<{ className: string; propertyName: string }> = [],
    widgetInstances: WidgetInstance[] = [],
) {
    let content = '\n'

    for (const a of attachmentsForThisView) {
        content += `    ${a.propertyName}: ${a.className};\n`;
    }

    for (const w of widgetInstances) {
        content += `    ${w.propertyName}: ${w.className};\n`;
    }

    childrenComponent.forEach((child) => {
        if (componentHierarchyMap.has(child) && componentHierarchyMap.get(child)?.dataTestIdSet.size) {
            const childName = child.split('.vue')[0]
            content += `    ${childName}: ${childName};\n`
        }
    })
    return `${content}\n`
}

function getConstructor(
    childrenComponent: Set<string>,
    componentHierarchyMap: Map<string, IComponentDependencies>,
    attachmentsForThisView: Array<{ className: string; propertyName: string }> = [],
    widgetInstances: WidgetInstance[] = [],
    options?: { testIdAttribute?: string },
) {
    let content = '    constructor(page: PwPage) {\n'
    const attr = (options?.testIdAttribute ?? "data-testid").trim() || "data-testid";
    content += `        super(page, { testIdAttribute: ${JSON.stringify(attr)} });\n`

    for (const a of attachmentsForThisView) {
        content += `        this.${a.propertyName} = new ${a.className}(page, this);\n`;
    }

    for (const w of widgetInstances) {
        content += `        this.${w.propertyName} = new ${w.className}(page, ${JSON.stringify(w.testId)});\n`;
    }

    childrenComponent.forEach((child) => {
        if (componentHierarchyMap.has(child) && componentHierarchyMap.get(child)?.dataTestIdSet.size) {
            const childName = child.split('.vue')[0]
            content += `    this.${childName} = new ${childName}(page);\n`
        }
    })
    content += '    }'
    return `${content}\n`
}

function generateClickMethod(methodName: string, formattedDataTestId: string, params: Record<string, string>) {
    let content: string;
    const name = `click${methodName}`;
    const paramBlock = formatParams(params);
    const paramBlockWithWait = paramBlock ? `${paramBlock}, wait: boolean = true` : `wait: boolean = true`;
    if (hasParam(params, "key")) {
        content = `  async ${name}(${paramBlockWithWait}) {\n    await this.clickByTestId(\`${formattedDataTestId}\`, "", wait);\n  }\n`;
    }
    else {
        content = `  async ${name}(wait: boolean = true) {\n    await this.clickByTestId("${formattedDataTestId}", "", wait);\n  }\n`;
    }
    return content;
}

function generateRadioMethod(methodName: string, formattedDataTestId: string) {
    const name = `select${methodName}`;
    const hasKey = formattedDataTestId.includes("${key}");
    if (hasKey) {
        return `  async ${name}(key: string, annotationText: string = "") {\n` +
            `    await this.clickByTestId(\`${formattedDataTestId}\`, annotationText);\n` +
            `  }\n`;
    }
    return `  async ${name}(annotationText: string = "") {\n` +
        `    await this.clickByTestId("${formattedDataTestId}", annotationText);\n` +
        `  }\n`;
}

function generateSelectMethod(methodName: string, formattedDataTestId: string) {
    const name = `select${methodName}`;
    const needsKey = formattedDataTestId.includes("${key}");
    const selectorExpr = needsKey
        ? `this.selectorForTestId(\`${formattedDataTestId}\`)`
        : `this.selectorForTestId("${formattedDataTestId}")`;
    const content: string = `  async ${name}(value: string, annotationText: string = "") {\n` +
        `        const selector = ${selectorExpr};\n` +
        `        await this.animateCursorToElement(selector, false, 500, annotationText);\n` +
        `        await this.page.selectOption(selector, value);\n` +
        `    }\n\n`;
    return content;
}

function generateVSelectMethod(methodName: string, formattedDataTestId: string) {
    const name = `select${methodName}`;
    const content = [
        `  async ${name}(value: string, timeOut = 500, annotationText: string = "") {\n`,
        `    await this.selectVSelectByTestId("${formattedDataTestId}", value, timeOut, annotationText);\n`,
        "  }\n",
    ].join('');
    return content;
}

function generateTypeMethod(methodName: string, formattedDataTestId: string) {
    const name = `type${methodName}`;
    const content: string = `  async ${name}(text: string, annotationText: string = "") {
    await this.fillInputByTestId("${formattedDataTestId}", text, annotationText);
  }\n`;
    return content;
}


function generateGetElementByDataTestId(methodName: string, nativeRole: string, formattedDataTestId: string, params: Record<string, string>) {
    // Avoid duplicate getters when the same base name exists for different roles.
    // Example: "PackageHash" can exist as both "-input" and "-button".
    const roleSuffix = upperFirst(nativeRole || "Element");
    const baseName = upperFirst(methodName);
    const name = baseName.endsWith(roleSuffix)
        ? `get${baseName}`
        : `get${baseName}${roleSuffix}`;
    const needsKey = hasParam(params, "key") || formattedDataTestId.includes("${key}");

    if (needsKey) {
        return `      ${name}(key: string) {\n` +
            `        return this.locatorByTestId(\`${formattedDataTestId}\`);\n` +
            `    }\n`;
    }

    return `      ${name}() {\n` +
        `        return this.locatorByTestId("${formattedDataTestId}");\n` +
        `    }\n\n`;
}

