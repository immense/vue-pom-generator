name: Release

on:
  pull_request:
    branches:
      - main

  push:
    branches:
      - main

  workflow_dispatch:

concurrency:
  group: release-main
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install
        run: npm ci

      - name: Typecheck
        run: npm run typecheck

      - name: Test
        run: npm test

      - name: Build
        run: npm run build

  release:
    name: Release
    needs: test
    runs-on: ubuntu-latest
    if: ((github.event_name == 'push' && github.ref == 'refs/heads/main' && github.actor != 'github-actions[bot]') || github.event_name == 'workflow_dispatch') && vars.ENABLE_AUTO_RELEASE == 'true'
    permissions:
      contents: write
    steps:
      - name: Checkout (full history + tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
          registry-url: https://registry.npmjs.org

      - name: Install
        run: npm ci

      - name: Compute next version (patch)
        id: next
        run: |
          node -e "const { execSync } = require('child_process'); const fs=require('fs');
          const pkgPath='package.json';
          const pkg=JSON.parse(fs.readFileSync(pkgPath,'utf8'));
          const tagsRaw=execSync(\"git tag --list 'v*' --sort=-v:refname\", { stdio: ['ignore','pipe','ignore'] }).toString().trim();
          const latestTag=tagsRaw.split(/\r?\n/).filter(Boolean)[0] || '';
          function bumpPatch(v){ const m=/^(\d+)\.(\d+)\.(\d+)$/.exec(v); if(!m) throw new Error('Invalid semver: '+v); return m[1] + '.' + m[2] + '.' + (Number(m[3]) + 1); }
          const nextVersion = latestTag ? bumpPatch(latestTag.replace(/^v/,'')) : '0.0.1';
          if(pkg.version === nextVersion){ throw new Error('Next version equals current package.json version: '+nextVersion); }
          console.log('nextVersion='+nextVersion);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, 'version=' + nextVersion + '\\n');
          fs.appendFileSync(process.env.GITHUB_OUTPUT, 'previous_tag=' + latestTag + '\\n');"

      - name: Generate release notes (agentic Copilot CLI)
        env:
          COPILOT_GITHUB_TOKEN: ${{ secrets.COPILOT_GITHUB_TOKEN }}
          GH_TOKEN: ${{ github.token }}
          RELEASE_REPOSITORY: ${{ github.repository }}
          RELEASE_VERSION: ${{ steps.next.outputs.version }}
          RELEASE_PREVIOUS_TAG: ${{ steps.next.outputs.previous_tag }}
          COPILOT_MODEL: gpt-5
        run: |
          set -euo pipefail

          if [ -z "${COPILOT_GITHUB_TOKEN}" ]; then
            echo "::error::Missing required secret COPILOT_GITHUB_TOKEN (needed for Copilot CLI release note generation)."
            exit 1
          fi
          if [ -z "${GH_TOKEN}" ]; then
            echo "::error::Missing required env var GH_TOKEN (needed for GitHub API queries used in release note generation)."
            exit 1
          fi

          VERSION="${RELEASE_VERSION}"
          PREV_TAG="${RELEASE_PREVIOUS_TAG}"

          if [ -n "$PREV_TAG" ]; then
            RANGE="$PREV_TAG..HEAD"
          else
            RANGE=""
          fi

          COMMITS="$(git log --pretty=format:'- %s (%an) [%h]' $RANGE)"
          if [ -n "$RANGE" ]; then
            DIFFSTAT="$(git diff --stat $RANGE)"
            NAME_STATUS="$(git diff --name-status $RANGE)"
            SINCE_ISO="$(git show -s --format=%cI "$PREV_TAG")"
          else
            DIFFSTAT="$(git show --stat)"
            NAME_STATUS="$(git show --name-status)"
            SINCE_ISO=""
          fi
          UNTIL_ISO="$(git show -s --format=%cI HEAD)"

          # Collect merged PRs in window (best-effort, but fail-fast if gh errors).
          MERGED_PRS=""
          if [ -n "$SINCE_ISO" ]; then
            Q="repo:${RELEASE_REPOSITORY} is:pr is:merged merged:>=${SINCE_ISO} merged:<=${UNTIL_ISO}"
          else
            Q="repo:${RELEASE_REPOSITORY} is:pr is:merged"
          fi

          for page in 1 2 3 4 5; do
            RESP="$(gh api -X GET search/issues -f "q=${Q}" -f per_page=100 -f "page=${page}" --jq '.items')"
            COUNT="$(printf '%s' "$RESP" | jq 'length')"
            if [ "$COUNT" -eq 0 ]; then
              break
            fi
            MERGED_PRS+="$(printf '%s' "$RESP" | jq -r '.[] | "- #\(.number) \(.title) (\(.html_url)) (by @\(.user.login))"')"
            MERGED_PRS+="\n"
            if [ "$COUNT" -lt 100 ]; then
              break
            fi
          done

          PROMPT_FILE="/tmp/release-notes-prompt.txt"
          cat > "$PROMPT_FILE" << 'EOF'
          You write concise, high-signal GitHub release notes in Markdown. Use headings and bullets.
          Do not invent changes; only summarize what is provided.

          Follow this structure:
          - ## Highlights (3-6 bullets)
          - ## Changes (bulleted; group by theme when possible)
          - ## Breaking Changes (only if any)
          - ## Pull Requests Included (bulleted, with links)
          - ## Testing (brief; mention if none)

          Output only Markdown.
          EOF

          {
            echo ""
            echo "Generate release notes for version v${VERSION}."
            echo ""
            if [ -n "$PREV_TAG" ]; then
              echo "Compare range: ${PREV_TAG}..HEAD (exclude the release bump commit if it appears)."
              echo "Window: merged PRs between ${SINCE_ISO} and ${UNTIL_ISO}."
            else
              echo "This is the initial release; summarize the project based on commit history."
              echo "Window: recent context up to ${UNTIL_ISO}."
            fi
            echo ""
            echo "Repository: ${RELEASE_REPOSITORY}"
            echo ""
            echo "Commits:"
            echo "${COMMITS:-<no commits>}"
            echo ""
            echo "Diffstat:"
            echo "${DIFFSTAT:-<no stats>}"
            echo ""
            echo "Files (name-status):"
            echo "${NAME_STATUS:-<no files>}"
            echo ""
            echo "Merged pull requests in this release window:"
            if [ -n "${MERGED_PRS//\n/}" ]; then
              printf '%b' "$MERGED_PRS"
            else
              echo "<none found>"
            fi
          } >> "$PROMPT_FILE"

          ./node_modules/.bin/copilot \
            --log-level none \
            --stream off \
            --model "${COPILOT_MODEL}" \
            --prompt "$(cat "$PROMPT_FILE")" \
            --silent \
            > RELEASE_NOTES.md

          test -s RELEASE_NOTES.md

      - name: Bump package.json version
        run: |
          node -e "const fs=require('fs'); const pkgPath='package.json'; const pkg=JSON.parse(fs.readFileSync(pkgPath,'utf8')); pkg.version=process.env.NEXT_VERSION; fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');"
        env:
          NEXT_VERSION: ${{ steps.next.outputs.version }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit version bump
        run: |
          git add package.json
          git commit -m "chore(release): v${{ steps.next.outputs.version }} [skip ci]"

      - name: Tag release
        run: git tag "v${{ steps.next.outputs.version }}"

      - name: Push commit + tag
        run: git push origin HEAD:main --follow-tags

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.next.outputs.version }}
          body_path: RELEASE_NOTES.md
